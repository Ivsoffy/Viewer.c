        -:    0:Source:test_viewer.c
        -:    0:Graph:test_viewer.gcno
        -:    0:Data:test_viewer.gcda
        -:    0:Runs:18
        -:    1:/*
        -:    2: * DO NOT EDIT THIS FILE. Generated by checkmk.
        -:    3: * Edit the original source file "test/headers.check" instead.
        -:    4: */
        -:    5:
        -:    6:#include <check.h>
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:
        -:   10:#include "3d_viewer_my/affins.h"
        -:   11:#include "3d_viewer_my/obj_reader.h"
        -:   12:#define TOL 0.000001
        -:   13:#define OK 1
        1:   14:START_TEST(affins_move_1) {
        -:   15:  vector *vectors;
        -:   16:  surface_dot *surface;
        1:   17:  int count_vector = 0, count_surface = 0;
        1:   18:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:   19:                       &count_surface);
        1:   20:  vector origin_vectors[3] = {40, -20, -20, 40, -20, 20, 0, -20, 20};
        1:   21:  count_vector = 3;
        1:   22:  vectors = move_xyz(vectors, count_vector, 20, 0, 0);
        4:   23:  for (int i = 0; i < count_vector; i++) {
       3*:   24:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:   25:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:   26:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:   27:  }
        1:   28:}
        -:   29:END_TEST
        -:   30:
        1:   31:START_TEST(affins_move_2) {
        -:   32:  vector *vectors;
        -:   33:  surface_dot *surface;
        1:   34:  int count_vector = 0, count_surface = 0;
        1:   35:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:   36:                       &count_surface);
        1:   37:  vector origin_vectors[3] = {0, -20, -20, 0, -20, 20, -40, -20, 20};
        1:   38:  count_vector = 3;
        1:   39:  vectors = move_xyz(vectors, count_vector, -20, 0, 0);
        4:   40:  for (int i = 0; i < count_vector; i++) {
       3*:   41:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:   42:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:   43:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:   44:  }
        1:   45:}
        -:   46:END_TEST
        -:   47:
        1:   48:START_TEST(affins_move_3) {
        -:   49:  vector *vectors;
        -:   50:  surface_dot *surface;
        1:   51:  int count_vector = 0, count_surface = 0;
        1:   52:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:   53:                       &count_surface);
        1:   54:  vector origin_vectors[3] = {40, 0, 0, 40, 0, 40, 0, 0, 40};
        1:   55:  count_vector = 3;
        1:   56:  vectors = move_xyz(vectors, count_vector, 20, 20, 20);
        4:   57:  for (int i = 0; i < count_vector; i++) {
       3*:   58:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:   59:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:   60:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:   61:  }
        1:   62:}
        -:   63:END_TEST
        -:   64:
        1:   65:START_TEST(affins_size_1) {
        -:   66:  vector *vectors;
        -:   67:  surface_dot *surface;
        1:   68:  int count_vector = 0, count_surface = 0;
        1:   69:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:   70:                       &count_surface);
        1:   71:  vector origin_vectors[3] = {40, -20, -20, 40, -20, 20, -40, -20, 20};
        1:   72:  count_vector = 3;
        1:   73:  vectors = size_xyz(vectors, count_vector, 2, 1, 1);
        4:   74:  for (int i = 0; i < count_vector; i++) {
       3*:   75:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:   76:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:   77:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:   78:  }
        1:   79:}
        -:   80:END_TEST
        -:   81:
        1:   82:START_TEST(affins_size_2) {
        -:   83:  vector *vectors;
        -:   84:  surface_dot *surface;
        1:   85:  int count_vector = 0, count_surface = 0;
        1:   86:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:   87:                       &count_surface);
        1:   88:  vector origin_vectors[3] = {-40, -20, -20, -40, -20, 20, 40, -20, 20};
        1:   89:  count_vector = 3;
        1:   90:  vectors = size_xyz(vectors, count_vector, -2, 1, 1);
        4:   91:  for (int i = 0; i < count_vector; i++) {
       3*:   92:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:   93:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:   94:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:   95:  }
        1:   96:}
        -:   97:END_TEST
        -:   98:
        1:   99:START_TEST(affins_size_3) {
        -:  100:  vector *vectors;
        -:  101:  surface_dot *surface;
        1:  102:  int count_vector = 0, count_surface = 0;
        1:  103:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  104:                       &count_surface);
        1:  105:  vector origin_vectors[3] = {40, -40, -40, 40, -40, 40, -40, -40, 40};
        1:  106:  count_vector = 3;
        1:  107:  vectors = size_xyz(vectors, count_vector, 2, 2, 2);
        4:  108:  for (int i = 0; i < count_vector; i++) {
       3*:  109:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  110:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  111:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  112:  }
        1:  113:}
        -:  114:END_TEST
        -:  115:
        1:  116:START_TEST(affins_rotation_x_1) {
        -:  117:  vector *vectors;
        -:  118:  surface_dot *surface;
        1:  119:  int count_vector = 0, count_surface = 0;
        1:  120:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  121:                       &count_surface);
        1:  122:  vector origin_vectors[3] = {20, -20, -20, 20, -20, 20, -20, -20, 20};
        1:  123:  count_vector = 3;
        1:  124:  vectors = rotation_x(vectors, count_vector, 0);
        4:  125:  for (int i = 0; i < count_vector; i++) {
       3*:  126:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  127:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  128:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  129:  }
        1:  130:}
        -:  131:END_TEST
        -:  132:
        1:  133:START_TEST(affins_rotation_x_2) {
        -:  134:  vector *vectors;
        -:  135:  surface_dot *surface;
        1:  136:  int count_vector = 0, count_surface = 0;
        1:  137:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  138:                       &count_surface);
        1:  139:  vector origin_vectors[3] = {20, 20, 20, 20, 20, -20, -20, 20, -20};
        1:  140:  count_vector = 3;
        1:  141:  vectors = rotation_x(vectors, count_vector, M_PI);
        4:  142:  for (int i = 0; i < count_vector; i++) {
       3*:  143:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  144:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  145:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  146:  }
        1:  147:}
        -:  148:END_TEST
        -:  149:
        1:  150:START_TEST(affins_rotation_x_3) {
        -:  151:  vector *vectors;
        -:  152:  surface_dot *surface;
        1:  153:  int count_vector = 0, count_surface = 0;
        1:  154:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  155:                       &count_surface);
        1:  156:  vector origin_vectors[3] = {20, -20, 20, 20, 20, 20, -20, 20, 20};
        1:  157:  count_vector = 3;
        1:  158:  vectors = rotation_x(vectors, count_vector, M_PI / 2);
        4:  159:  for (int i = 0; i < count_vector; i++) {
       3*:  160:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  161:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  162:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  163:  }
        1:  164:}
        -:  165:END_TEST
        -:  166:
        1:  167:START_TEST(affins_rotation_y_1) {
        -:  168:  vector *vectors;
        -:  169:  surface_dot *surface;
        1:  170:  int count_vector = 0, count_surface = 0;
        1:  171:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  172:                       &count_surface);
        1:  173:  vector origin_vectors[3] = {20, -20, -20, 20, -20, 20, -20, -20, 20};
        1:  174:  count_vector = 3;
        1:  175:  vectors = rotation_y(vectors, count_vector, 0);
        4:  176:  for (int i = 0; i < count_vector; i++) {
       3*:  177:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  178:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  179:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  180:  }
        1:  181:}
        -:  182:END_TEST
        -:  183:
        1:  184:START_TEST(affins_rotation_y_2) {
        -:  185:  vector *vectors;
        -:  186:  surface_dot *surface;
        1:  187:  int count_vector = 0, count_surface = 0;
        1:  188:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  189:                       &count_surface);
        1:  190:  vector origin_vectors[3] = {-20, -20, 20, -20, -20, -20, 20, -20, -20};
        1:  191:  count_vector = 3;
        1:  192:  vectors = rotation_y(vectors, count_vector, M_PI);
        4:  193:  for (int i = 0; i < count_vector; i++) {
       3*:  194:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  195:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  196:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  197:  }
        1:  198:}
        -:  199:END_TEST
        -:  200:
        1:  201:START_TEST(affins_rotation_y_3) {
        -:  202:  vector *vectors;
        -:  203:  surface_dot *surface;
        1:  204:  int count_vector = 0, count_surface = 0;
        1:  205:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  206:                       &count_surface);
        1:  207:  vector origin_vectors[3] = {-20, -20, -20, 20, -20, -20, 20, -20, 20};
        1:  208:  count_vector = 3;
        1:  209:  vectors = rotation_y(vectors, count_vector, M_PI / 2);
        4:  210:  for (int i = 0; i < count_vector; i++) {
       3*:  211:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  212:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  213:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  214:  }
        1:  215:}
        -:  216:END_TEST
        -:  217:
        1:  218:START_TEST(affins_rotation_z_1) {
        -:  219:  vector *vectors;
        -:  220:  surface_dot *surface;
        1:  221:  int count_vector = 0, count_surface = 0;
        1:  222:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  223:                       &count_surface);
        1:  224:  vector origin_vectors[3] = {20, -20, -20, 20, -20, 20, -20, -20, 20};
        1:  225:  count_vector = 3;
        1:  226:  vectors = rotation_z(vectors, count_vector, 0);
        4:  227:  for (int i = 0; i < count_vector; i++) {
       3*:  228:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  229:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  230:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  231:  }
        1:  232:}
        -:  233:END_TEST
        -:  234:
        1:  235:START_TEST(affins_rotation_z_2) {
        -:  236:  vector *vectors;
        -:  237:  surface_dot *surface;
        1:  238:  int count_vector = 0, count_surface = 0;
        1:  239:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  240:                       &count_surface);
        1:  241:  vector origin_vectors[3] = {-20, 20, -20, -20, 20, 20, 20, 20, 20};
        1:  242:  count_vector = 3;
        1:  243:  vectors = rotation_z(vectors, count_vector, M_PI);
        4:  244:  for (int i = 0; i < count_vector; i++) {
       3*:  245:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  246:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  247:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  248:  }
        1:  249:}
        -:  250:END_TEST
        -:  251:
        1:  252:START_TEST(affins_rotation_z_3) {
        -:  253:  vector *vectors;
        -:  254:  surface_dot *surface;
        1:  255:  int count_vector = 0, count_surface = 0;
        1:  256:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  257:                       &count_surface);
        1:  258:  vector origin_vectors[3] = {-20, -20, -20, -20, -20, 20, -20, 20, 20};
        1:  259:  count_vector = 3;
        1:  260:  vectors = rotation_z(vectors, count_vector, M_PI / 2);
        4:  261:  for (int i = 0; i < count_vector; i++) {
       3*:  262:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       3*:  263:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       3*:  264:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  265:  }
        1:  266:}
        -:  267:END_TEST
        -:  268:
        1:  269:START_TEST(obj_reader_1) {
        -:  270:  vector *vectors;
        1:  271:  vector origin_vectors[8] = {20, -20, -20, 20,  -20, 20,  -20, -20,
        -:  272:                              20, -20, -20, -20, 20,  20,  -20, 20,
        -:  273:                              20, 20,  -20, 20,  20,  -20, 20,  -20};
        -:  274:  surface_dot *surface;
        1:  275:  int count_vector = 0, count_surface = 0;
        1:  276:  int error = obj_read("test/test_cube.obj", &vectors, &surface, &count_vector,
        -:  277:                       &count_surface);
       1*:  278:  ck_assert_int_eq(error, OK);
       1*:  279:  ck_assert_int_eq(count_vector, 8);
       1*:  280:  ck_assert_int_eq(count_surface, 12);
        9:  281:  for (int i = 0; i < count_vector; i++) {
       8*:  282:    ck_assert_double_eq_tol(vectors[i].x, origin_vectors[i].x, TOL);
       8*:  283:    ck_assert_double_eq_tol(vectors[i].y, origin_vectors[i].y, TOL);
       8*:  284:    ck_assert_double_eq_tol(vectors[i].z, origin_vectors[i].z, TOL);
        -:  285:  }
        1:  286:}
        -:  287:END_TEST
        -:  288:
        1:  289:START_TEST(obj_reader_2) {
        -:  290:  vector *vectors;
        -:  291:  surface_dot *surface;
        1:  292:  int count_vector = 0, count_surface = 0;
        1:  293:  int error = obj_read("dont_exist.obj", &vectors, &surface, &count_vector,
        -:  294:                       &count_surface);
        -:  295:  // print_vector(vectors, count_vector);
        -:  296:  // print_surface(surface, count_surface);
       1*:  297:  ck_assert_int_eq(error, 0);
        1:  298:}
        -:  299:END_TEST
        -:  300:
       18:  301:int main(void) {
       18:  302:  Suite *s1 = suite_create("Core");
       18:  303:  TCase *tc1_1 = tcase_create("Core");
       18:  304:  SRunner *sr = srunner_create(s1);
        -:  305:  int nf;
        -:  306:
       18:  307:  suite_add_tcase(s1, tc1_1);
       18:  308:  tcase_add_test(tc1_1, affins_move_1);
       18:  309:  tcase_add_test(tc1_1, affins_move_2);
       18:  310:  tcase_add_test(tc1_1, affins_move_3);
       18:  311:  tcase_add_test(tc1_1, affins_size_1);
       18:  312:  tcase_add_test(tc1_1, affins_size_2);
       18:  313:  tcase_add_test(tc1_1, affins_size_3);
       18:  314:  tcase_add_test(tc1_1, affins_rotation_x_1);
       18:  315:  tcase_add_test(tc1_1, affins_rotation_x_2);
       18:  316:  tcase_add_test(tc1_1, affins_rotation_x_3);
       18:  317:  tcase_add_test(tc1_1, affins_rotation_y_1);
       18:  318:  tcase_add_test(tc1_1, affins_rotation_y_2);
       18:  319:  tcase_add_test(tc1_1, affins_rotation_y_3);
       18:  320:  tcase_add_test(tc1_1, affins_rotation_z_1);
       18:  321:  tcase_add_test(tc1_1, affins_rotation_z_2);
       18:  322:  tcase_add_test(tc1_1, affins_rotation_z_3);
       18:  323:  tcase_add_test(tc1_1, obj_reader_1);
       18:  324:  tcase_add_test(tc1_1, obj_reader_2);
        -:  325:
       18:  326:  srunner_run_all(sr, CK_ENV);
        1:  327:  nf = srunner_ntests_failed(sr);
        1:  328:  srunner_free(sr);
        -:  329:
        1:  330:  return nf == 0 ? 0 : 1;
        -:  331:}
